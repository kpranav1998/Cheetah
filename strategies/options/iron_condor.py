from __future__ import annotations

from datetime import date
from typing import Any

import pandas as pd

from strategies.options.base_options import BaseOptionsStrategy, OptionsLeg, OptionsSignal
from strategies.base import Signal, SignalType
from strategies.registry import register


@register
class IronCondorStrategy(BaseOptionsStrategy):
    """
    Sell OTM call + sell OTM put, buy further OTM call + put for protection.
    Profits when underlying stays within a range.
    """
    name = "iron_condor"

    def __init__(self):
        self.otm_distance_pct = 3.0  # Short strikes at Â±3% from spot
        self.wing_width_pct = 2.0    # Long strikes 2% further out
        self.profit_target_pct = 50.0
        self.stop_loss_pct = 100.0
        self.min_dte = 7
        self.max_dte = 30

    def configure(self, params: dict[str, Any]) -> None:
        self.otm_distance_pct = params.get("otm_distance_pct", self.otm_distance_pct)
        self.wing_width_pct = params.get("wing_width_pct", self.wing_width_pct)
        self.profit_target_pct = params.get("profit_target_pct", self.profit_target_pct)
        self.stop_loss_pct = params.get("stop_loss_pct", self.stop_loss_pct)

    def select_strikes(
        self, underlying_price: float, options_chain: pd.DataFrame, params: dict[str, Any]
    ) -> list[OptionsLeg]:
        short_call_strike = self._nearest_strike(
            options_chain, underlying_price * (1 + self.otm_distance_pct / 100)
        )
        short_put_strike = self._nearest_strike(
            options_chain, underlying_price * (1 - self.otm_distance_pct / 100)
        )
        long_call_strike = self._nearest_strike(
            options_chain, short_call_strike * (1 + self.wing_width_pct / 100)
        )
        long_put_strike = self._nearest_strike(
            options_chain, short_put_strike * (1 - self.wing_width_pct / 100)
        )

        expiry = options_chain.attrs.get("expiry", date.today())

        return [
            OptionsLeg(option_type="CE", strike=short_call_strike, expiry=expiry, action="SELL"),
            OptionsLeg(option_type="CE", strike=long_call_strike, expiry=expiry, action="BUY"),
            OptionsLeg(option_type="PE", strike=short_put_strike, expiry=expiry, action="SELL"),
            OptionsLeg(option_type="PE", strike=long_put_strike, expiry=expiry, action="BUY"),
        ]

    def entry_condition(self, df: pd.DataFrame, chain: pd.DataFrame) -> bool:
        # Simple: always enter if no open position (engine handles this)
        return True

    def exit_condition(
        self, df: pd.DataFrame, chain: pd.DataFrame, entry_signal: OptionsSignal, current_pnl: float
    ) -> bool:
        if entry_signal.max_profit and current_pnl >= entry_signal.max_profit * (self.profit_target_pct / 100):
            return True
        if entry_signal.max_loss and current_pnl <= entry_signal.max_loss * (self.stop_loss_pct / 100):
            return True
        return False

    def generate_signals(self, df: pd.DataFrame) -> list[Signal]:
        # Options signals are generated by the OptionsBacktestEngine, not here
        return []

    def _nearest_strike(self, chain: pd.DataFrame, target: float) -> float:
        strikes = chain["strike"].values
        idx = abs(strikes - target).argmin()
        return float(strikes[idx])

    def parameter_space(self) -> dict[str, list[Any]]:
        return {
            "otm_distance_pct": [2.0, 3.0, 5.0],
            "wing_width_pct": [1.0, 2.0, 3.0],
        }

    def get_params(self) -> dict[str, Any]:
        return {
            "otm_distance_pct": self.otm_distance_pct,
            "wing_width_pct": self.wing_width_pct,
            "profit_target_pct": self.profit_target_pct,
            "stop_loss_pct": self.stop_loss_pct,
        }
